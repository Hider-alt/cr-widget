{
  "always_run_in_app" : false,
  "icon" : {
    "color" : "orange",
    "glyph" : "crown"
  },
  "name" : "Clash Royale",
  "script" : "\/******************************\n * Info\n *****************************\/\n\n\/*****************************\n * How to setup: Look on the repo https:\/\/github.com\/Hider-alt\/cr-widget\/blob\/main\/README.md\n\n * Version History:\n * v1.0 -> Initial release\n * v1.0.1 -> Changes in chest display & Minor fixes (some chests caused the widget to crash)\n\n * Credits: RoyaleAPI\n\n *****************************\/\n\n\/******************************\n * Configuration\n *****************************\/\n\n\/\/ Get token for free at https:\/\/developer.clashroyale.com\/#\/account\n\/\/ Set in \"allowed IP\" this: 45.79.218.79\n\/\/ Set whatever you want in name and description\n\/\/ Paste the Token below\nconst API_TOKEN = ''\n\n\/\/ Set your tag here or in widget args\nlet ACCOUNT_TAG = '#'\n\nconst battlesText = 'Battles';\nconst winText = 'Win';\nconst recordText = 'Record';\nconst deckText = 'Deck';\nconst upcomingChestsText = 'Next chests';\nconst updateAvailableText = 'New update available! Click the widget';\n\n\n\/******************************\n * Setup\n *****************************\/\n\nconst VERSION = 'v1.0.1';\nconst BASE_API_URL = \"https:\/\/proxy.royaleapi.dev\/v1\";\nACCOUNT_TAG = args.widgetParameter || ACCOUNT_TAG || '';\nconst WIDGET_FAMILY = config.widgetFamily || 'large';\n\nconst widget = new ListWidget();\nconst fm = FileManager.iCloud();\n\nconst titleFont = Font.blackSystemFont(WIDGET_FAMILY === 'large' ? 18 : 16);\nconst h2Font = Font.boldSystemFont(WIDGET_FAMILY === 'large' ? 14 : 12);\nconst subtitleFont = Font.mediumRoundedSystemFont(WIDGET_FAMILY === 'large' ? 10 : 8);\n\nconst areUpdatesAvailable = await checkRepoUpdates();\n\nif (areUpdatesAvailable)\n    widget.url = 'https:\/\/github.com\/Hider-alt\/cr-widget\/blob\/main\/docs\/update.md';\nelse\n    widget.url = `https:\/\/royaleapi.com\/player\/${ACCOUNT_TAG.replace('#', '')}`;\n\nconst accountData = await getAccountData(ACCOUNT_TAG);\nawait buildLayout(widget);\n\nScript.setWidget(widget);\nScript.complete();\nawait widget.presentLarge();\n\n\n\/******************************\n * Widget functions\n *****************************\/\n\nasync function buildLayout(widget) {\n    let N, chests;\n\n    switch (WIDGET_FAMILY) {\n        case 'medium':\n            widget.setPadding(10, 0, 10, 0);\n\n            await addHeader(widget);\n            widget.addSpacer();\n\n            N = 6;\n            chests = getNChests(accountData.upcomingChests, N);\n            await addUpcomingChests(widget, chests);\n\n            break;\n        case 'large':\n            widget.setPadding(15, 0, 10, 0);\n\n            await addHeader(widget);\n            widget.addSpacer();\n\n            addStats(widget)\n            widget.addSpacer();\n\n            await addDeck(widget);\n            widget.addSpacer();\n\n            \/\/ Get first N chests (reduce N if widget crashes) (min 4 chests)\n            N = 4\n            chests = getNChests(accountData.upcomingChests, N);\n            await addUpcomingChests(widget, chests, Math.max(4, N \/ 2));\n\n            break;\n        default:\n            throw new Error('Invalid widget size');\n    }\n}\n\n\nasync function addHeader(containerStack) {\n    const header = containerStack.addStack();\n    header.layoutHorizontally();\n    header.centerAlignContent();\n    header.setPadding(5, 10, 0, 10);\n\n    const expImage = await getExpImage();\n    const expHeader = header.addImage(expImage);\n    expHeader.imageSize = new Size(26.9, 27.4);\n    header.addSpacer(4);\n\n    const accInfo = header.addStack();\n    accInfo.layoutVertically();\n\n    const nameText = accInfo.addText(accountData.name)\n    nameText.font = titleFont;\n\n    \/\/ Clan Text -> If updates available, add update text, else if clan name exists, add clan name\n    let clanText = areUpdatesAvailable ? accInfo.addText(updateAvailableText) : (accountData.clanName ? accInfo.addText(accountData.clanName) : \"\");\n    clanText.font = subtitleFont;\n    clanText.textColor = Color.lightGray();\n\n\n    header.addSpacer();\n\n    const trophiesInfo = header.addStack();\n    trophiesInfo.centerAlignContent();\n\n    const arenaImg = await getAsset(\n        accountData.leagueLevel ? `arenas\/league${accountData.leagueLevel}.png` : `arenas\/arena${accountData.arenaNumber}.png`,\n        accountData.leagueLevel ? `league${accountData.leagueLevel}` : `arena${accountData.arenaNumber}`\n    );\n    const trophyImg = trophiesInfo.addImage(arenaImg);\n    trophyImg.imageSize = new Size(30, 30);\n\n    const trophiesText = trophiesInfo.addText(accountData.trophies.toString());\n    trophiesText.font = titleFont;\n    trophiesText.textColor = new Color(\"#f0d04b\");\n}\n\n\nfunction addStats(containerStack) {\n    const statsRow = containerStack.addStack();\n    statsRow.layoutHorizontally();\n\n    const stats = [\n        {\n            title: winText,\n            value: (accountData.winRate * 100).toFixed(1).toString() + \"%\"\n        },\n        {\n            title: battlesText,\n            value: accountData.battles.toLocaleString(Device.locale().replaceAll(\"_\", \"-\"))\n        },\n        {\n            title: recordText,\n            value: accountData.bestTrophies.toString()\n        }\n    ];\n\n    for (const [index, stat] of stats.entries()) {\n        const statStack = statsRow.addStack();\n        statStack.layoutVertically();\n\n        const titleRow = statStack.addStack();\n        titleRow.addSpacer()\n        const statTitle = titleRow.addText(stat.title);\n        statTitle.font = subtitleFont;\n        statTitle.textColor = Color.lightGray();\n        statTitle.centerAlignText();\n        titleRow.addSpacer()\n\n        const statRow = statStack.addStack();\n        statRow.addSpacer()\n        const statValue = statRow.addText(stat.value);\n        statValue.font = titleFont;\n        statRow.addSpacer()\n\n        if (index !== stats.length - 1)\n            statsRow.addSpacer();\n    }\n}\n\n\nasync function addDeck(containerStack) {\n    const deck = containerStack.addStack();\n    deck.layoutVertically();\n    deck.centerAlignContent();\n    deck.setPadding(0, 10, 0, 10);\n\n    const deckTitle = deck.addText(deckText);\n    deckTitle.font = h2Font;\n\n    deck.addSpacer(2);\n\n    const cardsRow = new DrawContext();\n    cardsRow.opaque = false;\n    cardsRow.respectScreenScale = true;\n\n    const rowWidth = 800;\n    const cardWidth = (rowWidth \/ 8) - 2;\n    const cardHeight = cardWidth \/ 0.84;   \/\/ 0.84 is the ratio of the card image\n    cardsRow.size = new Size(rowWidth, cardHeight);\n\n    for (const [index, card] of accountData.deck.entries()) {\n        let cardImg = await getAsset(\n            `cards-150\/${card.name.toLowerCase().replaceAll(\" \", \"-\").replaceAll(\".\", \"\")}.png`,\n            card.name\n        );\n\n        cardsRow.drawImageInRect(cardImg, new Rect(index * (cardWidth + 2), 0, cardWidth, cardHeight));\n    }\n\n    deck.addImage(cardsRow.getImage());\n}\n\n\nasync function addUpcomingChests(containerStack, chests, chestsPerRow = 6) {\n    const chestsStack = containerStack.addStack();\n    chestsStack.layoutVertically();\n    chestsStack.centerAlignContent();\n    chestsStack.setPadding(0, 10, 0, 10);\n\n    const chestsTitle = chestsStack.addText(upcomingChestsText);\n    chestsTitle.font = h2Font;\n\n    chestsStack.addSpacer(2);\n\n    const chestsRow = new DrawContext();\n    chestsRow.opaque = false;\n    chestsRow.respectScreenScale = true;\n\n    const rowsCount = Math.ceil(chests.length \/ chestsPerRow);\n    const rowWidth = 1024;\n    const firstChestBonus = 35;                                              \/\/ First chest is bigger\n    const xPadding = 25;                                                     \/\/ Padding between chests\n    const extraPadding = firstChestBonus \/ chestsPerRow;                     \/\/ Extra padding for other rows after first\n    const yPadding = 40;                                                     \/\/ Padding between chests\n    const marginTop = 10;\n\n    const chestWidth = (rowWidth \/ chestsPerRow) - xPadding;\n    const firstChestWidth = chestWidth + firstChestBonus;\n    const nextChestWidth = chestWidth - firstChestBonus \/ (chestsPerRow - 1);\n    const chestHeight = chestWidth;                                          \/\/ 1.0 is the ratio of the chest image\n    chestsRow.size = new Size(rowWidth, (chestHeight + yPadding) * rowsCount + firstChestBonus + marginTop);\n\n    for (const [index, chest] of chests.entries()) {\n        const rowNumber = Math.floor(index \/ chestsPerRow);\n\n        let x, y, size;\n        if (index === 0) {\n            x = 0;\n            y = 0;\n            size = firstChestWidth;\n        } else {\n            if (rowNumber === 0) {\n                x = index * (nextChestWidth + xPadding) + firstChestBonus;\n                y = firstChestBonus \/ 2;\n            } else {\n                \/\/ Next rows\n                x = (index % chestsPerRow) * (nextChestWidth + xPadding + extraPadding);\n                y = rowNumber * (chestHeight + yPadding) + firstChestBonus;\n            }\n\n            size = nextChestWidth;\n        }\n\n        y += marginTop;\n\n        await drawUpcomingChest(chest, chestsRow, x, y, size, index === 0);\n    }\n\n    chestsStack.addImage(chestsRow.getImage());\n\n}\n\n\n\/******************************\n * Draw functions\n *****************************\/\n\nasync function drawUpcomingChest(chest, drawContext, x, y, size, big = false) {\n    \/\/ Chest name -> lowercase, no spaces, truncate at \"chest\", trim\n    const chestName = chest.name.toLowerCase().replaceAll(\" \", \"\").split(\"chest\")[0].trim();\n    const chestImg = await getAsset(\n        `chests\/chest-${chestName}.png`,\n        chest.name,\n        \"https:\/\/cdns3.royaleapi.com\/cdn-cgi\/image\/w=128,h=128,format=webp,quality=80\/static\/img\/\"\n    );\n\n    drawContext.drawImageInRect(chestImg, new Rect(x, y, size, size));\n\n    \/\/ Top right counter (in pill)\n    const pill = new Path();\n    const countText = `+${(chest.index + 1).toString()}`;\n    const pillWidth = 30 + countText.length * 18;\n    const pillHeight = 50;\n    const borderRadius = Math.min(25, pillHeight \/ 2);\n\n    const pillX = x + size - pillWidth + (big ? 5 : 10);\n    const pillY = y - (big ? 0 : 5);\n\n    pill.addRoundedRect(new Rect(pillX, pillY, pillWidth, pillHeight), borderRadius, borderRadius);\n    drawContext.addPath(pill);\n    drawContext.setFillColor(new Color(\"#454245CC\"));\n    drawContext.fillPath();\n\n    const fontSize = 36;\n    drawContext.setTextColor(Color.white());\n    drawContext.setFont(Font.mediumRoundedSystemFont(fontSize));\n\n    const fontWidth = fontSize \/ 1.55;\n    const leftPadding = (pillWidth - countText.length * fontWidth) \/ 2;\n    drawContext.drawTextInRect(countText, new Rect(pillX + leftPadding, pillY, pillWidth, pillHeight));\n}\n\n\n\/******************************\n * Images fetch functions\n *****************************\/\n\nasync function getExpImage() {\n    const w = 269;\n    const h = 274;\n    const expImage = await getAsset(\"ui\/experience.png\", \"exp\");\n\n    const dc = new DrawContext();\n    dc.opaque = false;\n    dc.respectScreenScale = true;\n    dc.size = new Size(w, h);\n\n    dc.drawImageInRect(expImage, new Rect(0, 0, w, h));\n\n    const fontSize = 130;\n    dc.setTextColor(Color.white());\n    dc.setFont(Font.boldSystemFont(fontSize));\n    const xCord = accountData.expLevel.toString().length > 1 ? 50 : 85;\n    dc.drawText(accountData.expLevel.toString(), new Point(xCord, 40));\n\n    return dc.getImage();\n}\n\n\nasync function getAsset(assetUrl, name, baseUrl = \"https:\/\/hider-alt.github.io\/cr-api-assets\/\") {\n    let image;\n\n    if (imageExists(name)) {\n        image = await getImage(name);\n\n        \/\/ Sometimes the image is corrupted, in that case, delete it and fetch it again\n        if (!image) {\n            deleteAsset(name);\n            return await getAsset(assetUrl, name, baseUrl);\n        }\n    }\n    else {\n        const imageRequest = new Request(baseUrl + assetUrl);\n\n        try {\n            image = await imageRequest.loadImage();\n        } catch (err) {\n            \/\/ If image not found, return unknown image\n            return getAsset(\"cards\/card-legendary-unknown.png\", \"unknown\");\n        }\n\n        saveImage(name, image);\n    }\n\n    return image;\n}\n\n\n\/******************************\n * API Functions\n *****************************\/\n\nasync function getAccountData() {\n    let tag = ACCOUNT_TAG.startsWith(\"#\") ? ACCOUNT_TAG : \"#\" + ACCOUNT_TAG;\n\n    tag = tag.replace(\"#\", \"%23\");\n\n    const accResponse = await supercellAPIRequest(\"\/players\/\" + tag);\n    const upcomingChests = await supercellAPIRequest(\"\/players\/\" + tag + \"\/upcomingchests\");\n\n    return {\n        name: accResponse.name,\n        clanName: accResponse.clan ? accResponse.clan.name : null,\n        expLevel: accResponse.expLevel,\n        trophies: accResponse.trophies,\n        winRate: accResponse.wins \/ accResponse.battleCount,\n        battles: accResponse.battleCount,\n        bestTrophies: accResponse.bestTrophies,\n        leagueLevel: accResponse.currentPathOfLegendSeasonResult != null ? accResponse.currentPathOfLegendSeasonResult.leagueNumber : null,\n        arenaNumber: parseInt(accResponse.arena.name.split(\" \")[1]),\n        deck: accResponse.currentDeck,\n        upcomingChests: upcomingChests.items\n    }\n}\n\nasync function supercellAPIRequest(route, method = 'GET') {\n    const url = BASE_API_URL + route;\n    const req = new Request(url);\n    req.method = method;\n    req.headers = {\n        Authorization: \"Bearer \" + API_TOKEN\n    }\n\n    let res;\n    try {\n        res = await req.loadJSON();\n        if (res.hasOwnProperty('reason')) {\n            let text;\n            switch (res['reason']) {\n                case 'accessDenied.invalidIp':\n                    text = \"Set '45.79.218.79' in the ALLOWED IP ADDRESSES section in https:\/\/developer.clashroyale.com\/#\/account\";\n                    break;\n                case 'accessDenied':\n                    text = \"Invalid token\";\n                    break;\n                case 'notFound':\n                    text = \"Player not found\";\n                    break;\n                default:\n                    text = res['reason'];\n            }\n\n            console.log(text);\n            throw new Error(text);\n        }\n    } catch (err) {\n        console.log(\"Error in: \" + url);\n        console.log(err);\n\n        throw new Error(err);\n    }\n\n    return res;\n}\n\n\/******************************\n * Utils Functions\n *****************************\/\n\nfunction getNChests(chests, n) {\n    \/\/ Half of N chests will be shown from 0 to N\/2, the other half from -6 to (-6 + N\/2)\n    \/\/ (If n > N\/2 + 6, show from 0 to N)\n    \n    if (n > chests.length \/ 2 + 6)\n        return chests.slice(0, n);\n    else\n        return chests.slice(0, n \/ 2).concat(chests.slice(-6, -6 + n \/ 2));\n}\n\n\nfunction imageExists(name) {\n    return fm.fileExists(fm.joinPath(fm.joinPath(fm.documentsDirectory(), \"cr-widget\"), name + \".png\"));\n}\n\nasync function getImage(name, ext=\".png\") {\n    if (!name) return null;\n\n    const base_path = fm.joinPath(fm.documentsDirectory(), \"cr-widget\")\n\n    const path = fm.joinPath(base_path, name + ext)\n    await fm.downloadFileFromiCloud(path)\n\n    return Image.fromFile(path)\n}\n\nfunction saveImage(name, image) {\n    const base_path = fm.joinPath(fm.documentsDirectory(), \"cr-widget\")\n\n    if (!fm.fileExists(base_path))\n        fm.createDirectory(base_path)\n\n    const path = fm.joinPath(base_path, name + \".png\")\n    fm.writeImage(path, image)\n}\n\nfunction deleteAsset(name) {\n    const path = fm.joinPath(fm.joinPath(fm.documentsDirectory(), \"cr-widget\"), name + \".png\");\n    fm.remove(path);\n}\n\nasync function checkRepoUpdates() {\n    return new Promise((resolve, reject) => {\n        const request = new Request('https:\/\/raw.githubusercontent.com\/Hider-alt\/cr-widget\/main\/version.json');\n        request.loadJSON().then(json => {\n            resolve(json['version'] !== VERSION);\n        }).catch(err => {\n            reject(err);\n        })\n    });\n}",
  "share_sheet_inputs" : [

  ]
}